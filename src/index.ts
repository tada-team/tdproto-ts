// Autogenerated. Do not edit.

type MessageLinks = MessageLink[];
/**
 * Small or large icon.
 */
export interface SingleIcon {
   /**
    * absolute url to icon.
    */
   url: string;

   /**
    * Icon width, in pixels.
    */
   width: number;

   /**
    * Icon height, in pixels.
    */
   height: number;

}

let NewSingleIcon = function(e: any): SingleIcon { return {url: e["url"], width: e["width"], height: e["height"]} }


/**
 * Icon data. Contains sm+lg (for uploaded image) OR stub+letters+color (for icon generated from display name).
 */
export interface IconData {
   /**
    * Small icon. Omitempty.
    */
   sm: SingleIcon | null;

   /**
    * Large image. Omitempty.
    */
   lg: SingleIcon | null;

   /**
    * Generated image with 1-2 letters. Omitempty.
    */
   stub: string;

   /**
    * Letters from stub icon. Omitempty.
    */
   letters: string;

   /**
    * Stub icon background color. Omitempty.
    */
   color: string;

}

let NewIconData = function(e: any): IconData { return {sm: NewSingleIcon(e["sm"]), lg: NewSingleIcon(e["lg"]), stub: e["stub"], letters: e["letters"], color: e["color"]} }


/**
 * {hostname}/features.js / {hostname}/features.json structure.
 */
export interface Features {
   /**
    * Current host.
    */
   host: string;

   /**
    * Build/revision of server side.
    */
   build: string;

   /**
    * Desktop application version.
    */
   desktopVersion: string;

   /**
    * Webclient version.
    */
   frontVersion: string;

   /**
    * Application title.
    */
   appTitle: string;

   /**
    * Static files server address.
    */
   userver: string;

   /**
    * Link to AppStore.
    */
   iOSApp: string;

   /**
    * Link to Google Play.
    */
   androidApp: string;

   /**
    * Default UI theme.
    */
   theme: string;

   /**
    * Minimal application version required for this server. Used for breaking changes.
    */
   minAppVersion: string;

   /**
    * Free registration allowed.
    */
   freeRegistration: boolean;

   /**
    * Maximum size of user's upload.
    */
   maxUploadMb: number;

   /**
    * Maximum number of forwarded messages.
    */
   maxLinkedMessages: number;

   /**
    * Maximum chars for: family_name, given_name, patronymic if any.
    */
   maxUsernamePartLength: number;

   /**
    * Maximum chars for group chat name.
    */
   maxGroupTitleLength: number;

   /**
    * Maximum chars for role in team.
    */
   maxRoleLength: number;

   /**
    * Maximum chars for mood in team.
    */
   maxMoodLength: number;

   /**
    * Maximum chars for text message.
    */
   maxMessageLength: number;

   /**
    * Maximum length for project and contact's sections names.
    */
   maxSectionLength: number;

   /**
    * Maximum length for tags.
    */
   maxTagLength: number;

   /**
    * Maximum length for task title.
    */
   maxTaskTitleLength: number;

   /**
    * Maximum teams for one account.
    */
   maxTeams: number;

   /**
    * Max inactivity seconds.
    */
   afkAge: number;

   /**
    * Password authentication enabled. Omitempty.
    */
   authByPassword: boolean;

   /**
    * QR-code / link authentication enabled. Omitempty.
    */
   authByQrCode: boolean;

   /**
    * SMS authentication enabled. Omitempty.
    */
   authBySms: boolean;

   /**
    * ICE servers for WebRTC.
    */
   iCEServers: ICEServer[];

   /**
    * True for onpremise installation.
    */
   customServer: boolean;

   /**
    * Name of instalation.
    */
   installationType: string;

   /**
    * Testing installation.
    */
   isTesting: boolean;

   /**
    * Yandex metrika counter id.
    */
   metrika: string;

   /**
    * Minimal chars number for starting global search.
    */
   minSearchLength: number;

   /**
    * Resend message in n seconds if no confirmation from server given.
    */
   resendTimeout: number;

   /**
    * Frontent sentry.io settings.
    */
   sentryDsnJS: string;

   /**
    * Message drafts saved on server.
    */
   serverDrafts: boolean;

   /**
    * Firebase application id for web-push notifacations.
    */
   firebaseAppId: string;

   /**
    * Firebase sender id for web-push notifacations.
    */
   firebaseSenderId: string;

   /**
    * Calls functions enabled.
    */
   calls: boolean;

   /**
    * Calls functions enabled for mobile applications.
    */
   mobileCalls: boolean;

   /**
    * Calls record enabled.
    */
   callsRecord: boolean;

   /**
    * Disallow call from multiply devices. Experimental. Omitempty.
    */
   onlyOneDevicePerCall: boolean;

   /**
    * Maximum number of participants per call. Omitempty.
    */
   maxParticipantsPerCall: number;

   /**
    * Safari push id for web-push notifacations.
    */
   safariPushId: string;

   /**
    * Team entity naming. Experimental.
    */
   terms: Terms;

   /**
    * Cross team communication. Experimental.
    */
   singleGroupTeams: boolean;

   /**
    * Wiki pages in chats. Experimental.
    */
   wikiPages: boolean;

   /**
    * Wiki pages in chats. Experimental. Omitempty.
    */
   allowAdminMute: boolean;

   /**
    * Deprecated.
    */
   taskChecklist: boolean;

   /**
    * Deprecated.
    */
   readonlyGroups: boolean;

   /**
    * Deprecated.
    */
   taskDashboard: boolean;

   /**
    * Deprecated.
    */
   taskMessages: boolean;

   /**
    * Deprecated.
    */
   taskPublic: boolean;

   /**
    * Deprecated.
    */
   taskTags: boolean;

}

let NewFeatures = function(e: any): Features { return {host: e["host"], build: e["build"], desktopVersion: e["desktop_version"], frontVersion: e["front_version"], appTitle: e["app_title"], userver: e["userver"], iOSApp: e["ios_app"], androidApp: e["android_app"], theme: e["theme"], minAppVersion: e["min_app_version"], freeRegistration: e["free_registration"], maxUploadMb: e["max_upload_mb"], maxLinkedMessages: e["max_linked_messages"], maxUsernamePartLength: e["max_username_part_length"], maxGroupTitleLength: e["max_group_title_length"], maxRoleLength: e["max_role_length"], maxMoodLength: e["max_mood_length"], maxMessageLength: e["max_message_length"], maxSectionLength: e["max_section_length"], maxTagLength: e["max_tag_length"], maxTaskTitleLength: e["max_task_title_length"], maxTeams: e["max_teams"], afkAge: e["afk_age"], authByPassword: e["auth_by_password"], authByQrCode: e["auth_by_qr_code"], authBySms: e["auth_by_sms"], iCEServers: e["ice_servers"].map(NewICEServer), customServer: e["custom_server"], installationType: e["installation_type"], isTesting: e["is_testing"], metrika: e["metrika"], minSearchLength: e["min_search_length"], resendTimeout: e["resend_timeout"], sentryDsnJS: e["sentry_dsn_js"], serverDrafts: e["server_drafts"], firebaseAppId: e["firebase_app_id"], firebaseSenderId: e["firebase_sender_id"], calls: e["calls"], mobileCalls: e["mobile_calls"], callsRecord: e["calls_record"], onlyOneDevicePerCall: e["only_one_device_per_call"], maxParticipantsPerCall: e["max_participants_per_call"], safariPushId: e["safari_push_id"], terms: NewTerms(e["terms"]), singleGroupTeams: e["single_group_teams"], wikiPages: e["wiki_pages"], allowAdminMute: e["allow_admin_mute"], taskChecklist: e["task_checklist"], readonlyGroups: e["readonly_groups"], taskDashboard: e["task_dashboard"], taskMessages: e["task_messages"], taskPublic: e["task_public"], taskTags: e["task_tags"]} }


/**
 * Interactive Connectivity Establishment Server for WEB Rtc connection.
 */
export interface ICEServer {
   /**
    * URls.
    */
   urls: string;

}

let NewICEServer = function(e: any): ICEServer { return {urls: e["urls"]} }


/**
 * Exprtimental translation fields for "team" entity renaming.
 */
export interface Terms {
}

let NewTerms = function(e: any): Terms { return {} }


/**
 * Audiocall information.
 */
export interface CallEvent {
   /**
    * Call start, iso date.
    */
   start: string | null;

   /**
    * Call finish, iso date.
    */
   finish: string | null;

   /**
    * Call record enabled.
    */
   audiorecord: boolean;

   /**
    * Call members.
    */
   onliners: CallOnliner[];

}

let NewCallEvent = function(e: any): CallEvent { return {start: e["start"], finish: e["finish"], audiorecord: e["audiorecord"], onliners: e["onliners"].map(NewCallOnliner)} }


/**
 * Call participant.
 */
export interface CallOnliner {
   /**
    * Contact id.
    */
   jid: JID;

   /**
    * Contact name.
    */
   displayName: string;

   /**
    * Contact icon.
    */
   icon: string;

   /**
    * Microphone muted. Computed from devices muted states.
    */
   muted: boolean;

   /**
    * Member devices, strictly one for now.
    */
   devices: CallDevice[];

}

let NewCallOnliner = function(e: any): CallOnliner { return {jid: e["jid"], displayName: e["display_name"], icon: e["icon"], muted: e["muted"], devices: e["devices"].map(NewCallDevice)} }


/**
 * Call participant device.
 */
export interface CallDevice {
   /**
    * Device muted.
    */
   muted: boolean;

   /**
    * Device description.
    */
   useragent: string;

}

let NewCallDevice = function(e: any): CallDevice { return {muted: e["muted"], useragent: e["useragent"]} }


/**
 * Mimimal chat representaion.
 */
export interface ChatShort {
   /**
    * Group/Task/Contact id.
    */
   jid: JID;

   /**
    * Chat type.
    */
   chatType: ChatType;

   /**
    * Title.
    */
   displayName: string;

   /**
    * Icon data.
    */
   icons: IconData | null;

}

let NewChatShort = function(e: any): ChatShort { return {jid: e["jid"], chatType: e["chat_type"], displayName: e["display_name"], icons: NewIconData(e["icons"])} }


/**
 * Mimimal chat representaion for deletion.
 */
export interface DeletedChat {
   /**
    * Group/Task/Contact id.
    */
   jid: JID;

   /**
    * Chat type.
    */
   chatType: ChatType;

   /**
    * Chat fields (related to concrete participan) version.
    */
   gentime: number;

   /**
    * Archive flag. Always true for this structure.
    */
   isArchive: boolean;

}

let NewDeletedChat = function(e: any): DeletedChat { return {jid: e["jid"], chatType: e["chat_type"], gentime: e["gentime"], isArchive: e["is_archive"]} }


/**
 * Chat (direct, group, task) representaion.
 */
export interface Chat {
   /**
    * Group/Task/Contact id.
    */
   jid: JID;

   /**
    * Chat type.
    */
   chatType: ChatType;

   /**
    * Base fields (not related to concrete participant) version. Omitempty.
    */
   baseGentime: number;

   /**
    * Chat fields related to concrete participan) version.
    */
   gentime: number;

   /**
    * Creation date, iso datetime.
    */
   created: string;

   /**
    * Title.
    */
   displayName: string;

   /**
    * Icons info.
    */
   icons: IconData | null;

   /**
    * Include unread messages to counters. Omitempty.
    */
   countersEnabled: boolean;

   /**
    * Can I call to this chat. Omitempty.
    */
   canCall: boolean;

   /**
    * Can I send message to this chat. Omitempty.
    */
   canSendMessage: boolean;

   /**
    * Why I can't send message to this chat (if can't). Omitempty.
    */
   cantSendMessageReason: string;

   /**
    * Description collapsed. Used for tasks only. Omitempty.
    */
   collapsed: boolean;

   /**
    * Last message draft, if any. Omitempty.
    */
   draft: string;

   /**
    * Last message draft version , if any. Omitempty.
    */
   draftNum: number;

   /**
    * Hidden chat. Omitempty.
    */
   hidden: boolean;

   /**
    * Push notifications enabled. Omitempty.
    */
   notificationsEnabled: boolean;

   /**
    * Number of importants messages. Omitempty.
    */
   numImportants: number;

   /**
    * Unreads conuter. Omitempty.
    */
   numUnread: number;

   /**
    * Mentions (@) counter. Omitempty.
    */
   numUnreadNotices: number;

   /**
    * Last message object. Omitempty.
    */
   lastMessage: Message | null;

   /**
    * Last read message id, if any. Omitempty.
    */
   lastReadMessageId: string;

   /**
    * Project / section id, if any. Omitempty.
    */
   section: string;

   /**
    * List of editable fields. Omitempty.
    */
   changeableFields: string[];

   /**
    * Is chat pinned on top. Omitempty.
    */
   pinned: boolean;

   /**
    * Sort oreding for pinned chat. Omitempty.
    */
   pinnedSortOrdering: number;

   /**
    * Non-archive participants number. Omitempty.
    */
   numMembers: number | null;

   /**
    * Can I delete this chat. Omitempty.
    */
   canDelete: boolean;

   /**
    * Group or task description. Omitempty.
    */
   description: string;

   /**
    * Present in feed (main screen). Omitempty.
    */
   feed: boolean;

   /**
    * Pinned message for this chat. Omitempty.
    */
   pinnedMessage: Message | null;

   /**
    * Custom color index from table of colors. Tasks only. Omitempty.
    */
   colorIndex: number | null;

   /**
    * Items in checklist. Tasks only. Omitempty.
    */
   numItems: number | null;

   /**
    * Checked items in checklist. Tasks only. Omitempty.
    */
   numCheckedItems: number | null;

   /**
    * Assignee contact id. Tasks only. Omitempty.
    */
   assignee: JID | null;

   /**
    * Task number in this team. Omitempty.
    */
   num: number;

   /**
    * Task observers id's. Omitempty.
    */
   observers: JID[] | null;

   /**
    * Task creator. Omitempty.
    */
   owner: JID | null;

   /**
    * Task status. May be custom. Omitempty.
    */
   taskStatus: string;

   /**
    * Task title. Generated from number and description. Omitempty.
    */
   title: string;

   /**
    * Task done date in iso format, if any. Omitempty.
    */
   done: string;

   /**
    * Task done reason, if any. Omitempty.
    */
   doneReason: string;

   /**
    * Task deadline in iso format, if any. Omitempty.
    */
   deadline: string;

   /**
    * Is task deadline expired. Omitempty.
    */
   deadlineExpired: boolean;

   /**
    * Links in description. Omitempty.
    */
   links: MessageLinks;

   /**
    * Task tags list, if any. Omitempty.
    */
   tags: string[];

   /**
    * Task importance, if available in team. Omitempty.
    */
   importance: number | null;

   /**
    * Task urgency, if available in team. Omitempty.
    */
   urgency: number | null;

   /**
    * Task spent time, number. Omitempty.
    */
   spentTime: number | null;

   /**
    * Task complexity, number. Omitempty.
    */
   complexity: number | null;

   /**
    * Used for "Create task from messages...". Omitempty.
    */
   linkedMessages: any[];

   /**
    * Checklist items. Task only. Omitempty.
    */
   items: TaskItem[];

   /**
    * Parent tasks. Omitempty.
    */
   parents: Subtask[];

   /**
    * Tab names. Omitempty.
    */
   tabs: TaskTabKey[] | null;

   /**
    * My status in group chat. Omitempty.
    */
   status: GroupStatus;

   /**
    * Group chat members. Omitempty.
    */
   members: GroupMembership[];

   /**
    * Can I add member to this group chat. Omitempty.
    */
   canAddMember: boolean;

   /**
    * Can I remove member from this group chat. Omitempty.
    */
   canRemoveMember: boolean;

   /**
    * Can I change member status in this group chat. Omitempty.
    */
   canChangeMemberStatus: boolean;

   /**
    * deprecated: use changeable fields. Omitempty.
    */
   canChangeSettings: boolean;

   /**
    * Any new team member will be added to this group chat. Omitempty.
    */
   defaultForAll: boolean;

   /**
    * Readonly for non-admins group chat (Like Channels in Telegram bug switchable). Omitempty.
    */
   readonlyForMembers: boolean;

   /**
    * Delete messages in this chat in seconds. Experemental function. Omitempty.
    */
   autocleanupAge: number | null;

   /**
    * Can other team member see this task/group chat. Omitempty.
    */
   public: boolean;

   /**
    * Can I join to this public group/task. Omitempty.
    */
   canJoin: boolean;

   /**
    * Can I delete any message in this chat. Omitempty.
    */
   canDeleteAnyMessage: boolean | null;

   /**
    * Can I change Important flag in any message in this chat. Omitempty.
    */
   canSetImportantAnyMessage: boolean | null;

}

let NewChat = function(e: any): Chat { return {jid: e["jid"], chatType: e["chat_type"], baseGentime: e["base_gentime"], gentime: e["gentime"], created: e["created"], displayName: e["display_name"], icons: NewIconData(e["icons"]), countersEnabled: e["counters_enabled"], canCall: e["can_call"], canSendMessage: e["can_send_message"], cantSendMessageReason: e["cant_send_message_reason"], collapsed: e["collapsed"], draft: e["draft"], draftNum: e["draft_num"], hidden: e["hidden"], notificationsEnabled: e["notifications_enabled"], numImportants: e["num_importants"], numUnread: e["num_unread"], numUnreadNotices: e["num_unread_notices"], lastMessage: NewMessage(e["last_message"]), lastReadMessageId: e["last_read_message_id"], section: e["section"], changeableFields: e["changeable_fields"], pinned: e["pinned"], pinnedSortOrdering: e["pinned_sort_ordering"], numMembers: e["num_members"], canDelete: e["can_delete"], description: e["description"], feed: e["feed"], pinnedMessage: NewMessage(e["pinned_message"]), colorIndex: e["color_index"], numItems: e["num_items"], numCheckedItems: e["num_checked_items"], assignee: e["assignee"], num: e["num"], observers: e["observers"], owner: e["owner"], taskStatus: e["task_status"], title: e["title"], done: e["done"], doneReason: e["done_reason"], deadline: e["deadline"], deadlineExpired: e["deadline_expired"], links: e["links"], tags: e["tags"], importance: e["importance"], urgency: e["urgency"], spentTime: e["spent_time"], complexity: e["complexity"], linkedMessages: e["linked_messages"], items: e["items"].map(NewTaskItem), parents: e["parents"].map(NewSubtask), tabs: e["tabs"], status: e["status"], members: e["members"].map(NewGroupMembership), canAddMember: e["can_add_member"], canRemoveMember: e["can_remove_member"], canChangeMemberStatus: e["can_change_member_status"], canChangeSettings: e["can_change_settings"], defaultForAll: e["default_for_all"], readonlyForMembers: e["readonly_for_members"], autocleanupAge: e["autocleanup_age"], public: e["public"], canJoin: e["can_join"], canDeleteAnyMessage: e["can_delete_any_message"], canSetImportantAnyMessage: e["can_set_important_any_message"]} }


/**
 * Link to sub/sup task.
 */
export interface Subtask {
   /**
    * Task id.
    */
   jid: JID;

   /**
    * Assignee contact id. Tasks only.
    */
   assignee: JID;

   /**
    * Task title. Generated from number and description.
    */
   title: string;

   /**
    * Task number in this team.
    */
   num: number;

   /**
    * Title.
    */
   displayName: string;

   /**
    * Can other team member see this task/group chat. Omitempty.
    */
   public: boolean;

}

let NewSubtask = function(e: any): Subtask { return {jid: e["jid"], assignee: e["assignee"], title: e["title"], num: e["num"], displayName: e["display_name"], public: e["public"]} }


/**
 * Task checklist item.
 */
export interface TaskItem {
   /**
    * Id. Omitempty.
    */
   uid: string;

   /**
    * Sort ordering. Omitempty.
    */
   sortOrdering: number;

   /**
    * Text or "#{OtherTaskNumber}".
    */
   text: string;

   /**
    * Item checked. Omitempty.
    */
   checked: boolean;

   /**
    * Can I toggle this item. Omitempty.
    */
   canToggle: boolean;

   /**
    * Link to subtask. Optional. Omitempty.
    */
   subtask: Subtask | null;

}

let NewTaskItem = function(e: any): TaskItem { return {uid: e["uid"], sortOrdering: e["sort_ordering"], text: e["text"], checked: e["checked"], canToggle: e["can_toggle"], subtask: NewSubtask(e["subtask"])} }


/**
 * Group chat membership status.
 */
export interface GroupMembership {
   /**
    * Contact id.
    */
   jid: JID;

   /**
    * Status in group.
    */
   status: GroupStatus;

   /**
    * Can I remove this member. Omitempty.
    */
   canRemove: boolean;

}

let NewGroupMembership = function(e: any): GroupMembership { return {jid: e["jid"], status: e["status"], canRemove: e["can_remove"]} }


/**
 * Uploaded media.
 */
export interface Upload {
   /**
    * Upload id.
    */
   uid: string;

   /**
    * Upload size in bytes.
    */
   size: number;

   /**
    * Mediafile duration (for audio/video only). Omitempty.
    */
   duration: number;

   /**
    * Filename.
    */
   name: string;

   /**
    * Absolute url.
    */
   url: string;

   /**
    * Preview details. Omitempty.
    */
   preview: UploadPreview | null;

   /**
    * Content type.
    */
   contentType: string;

   /**
    * Is animated (images only). Omitempty.
    */
   animated: boolean;

   /**
    * File still processing (video only). Omitempty.
    */
   processing: boolean;

   /**
    * PDF version of file. Experimental. Omitempty.
    */
   pdfVersion: PdfVersion | null;

}

let NewUpload = function(e: any): Upload { return {uid: e["uid"], size: e["size"], duration: e["duration"], name: e["name"], url: e["url"], preview: NewUploadPreview(e["preview"]), contentType: e["content_type"], animated: e["animated"], processing: e["processing"], pdfVersion: NewPdfVersion(e["pdf_version"])} }


/**
 * Upload preview.
 */
export interface UploadPreview {
   /**
    * Absolute url to image.
    */
   url: string;

   /**
    * Absolute url to high resolution image (retina).
    */
   url2x: string;

   /**
    * Width in pixels.
    */
   width: number;

   /**
    * Height in pixels.
    */
   height: number;

}

let NewUploadPreview = function(e: any): UploadPreview { return {url: e["url"], url2x: e["url_2x"], width: e["width"], height: e["height"]} }


/**
 * Chat message content.
 */
export interface MessageContent {
   /**
    * Text repesentation of message.
    */
   text: string;

   /**
    * Message type.
    */
   type: Mediatype;

   /**
    * Message subtype, if any. Omitempty.
    */
   subtype: Mediasubtype;

   /**
    * Upload id, if any. Omitempty.
    */
   upload: string;

   /**
    * Upload url, if any. Omitempty.
    */
   mediaUrl: string;

   /**
    * Upload size, if any. Omitempty.
    */
   size: number;

   /**
    * Upload duration, if any. Omitempty.
    */
   duration: number | null;

   /**
    * Upload stil processing, if any. Omitempty.
    */
   processing: boolean;

   /**
    * Upload preview height, in pixels, if any. Omitempty.
    */
   previewHeight: number;

   /**
    * Upload width, in pixels, if any. Omitempty.
    */
   previewWidth: number;

   /**
    * Upload preview absolute url, if any. Omitempty.
    */
   previewUrl: string;

   /**
    * Upload high resolution preview absolute url, if any. Omitempty.
    */
   preview2xUrl: string;

   /**
    * Upload name, if any. Omitempty.
    */
   name: string;

   /**
    * Upload is animated image, if any. Omitempty.
    */
   animated: boolean;

   /**
    * Change title (for "change" mediatype). Omitempty.
    */
   title: string;

   /**
    * Change old value (for "change" mediatype). Omitempty.
    */
   old: string | null;

   /**
    * Change new value (for "change" mediatype). Omitempty.
    */
   new: string | null;

   /**
    * Change actor contact id (for "change" mediatype). Omitempty.
    */
   actor: JID | null;

   /**
    * Comment. For audimessage. Omitempty.
    */
   comment: string;

   /**
    * Given name (for "contact" mediatype). Omitempty.
    */
   givenName: string | null;

   /**
    * Family name (for "contact" mediatype). Omitempty.
    */
   familyName: string | null;

   /**
    * Patronymic name (for "contact" mediatype). Omitempty.
    */
   patronymic: string | null;

   /**
    * Contact phones list (for "contact" mediatype). Omitempty.
    */
   phones: string[] | null;

   /**
    * Emails list (for "contact" mediatype). Omitempty.
    */
   emails: string[] | null;

   /**
    * Stickerpack name (for "sticker" subtype). Omitempty.
    */
   stickerpack: string;

   /**
    * Pdf version, if any. Omitempty.
    */
   pdfVersion: PdfVersion | null;

}

let NewMessageContent = function(e: any): MessageContent { return {text: e["text"], type: e["type"], subtype: e["subtype"], upload: e["upload"], mediaUrl: e["mediaURL"], size: e["size"], duration: e["duration"], processing: e["processing"], previewHeight: e["previewHeight"], previewWidth: e["previewWidth"], previewUrl: e["previewURL"], preview2xUrl: e["preview2xURL"], name: e["name"], animated: e["animated"], title: e["title"], old: e["old"], new: e["new"], actor: e["actor"], comment: e["comment"], givenName: e["given_name"], familyName: e["family_name"], patronymic: e["patronymic"], phones: e["phones"], emails: e["emails"], stickerpack: e["stickerpack"], pdfVersion: NewPdfVersion(e["pdf_version"])} }


/**
 * Chat message.
 */
export interface Message {
   /**
    * Message content struct.
    */
   content: MessageContent;

   /**
    * Simple plaintext message representation. Omitempty.
    */
   pushText: string;

   /**
    * Sender contact id.
    */
   from: JID;

   /**
    * Recipient jid.
    */
   to: JID;

   /**
    * Message uid.
    */
   messageId: string;

   /**
    * Message creation datetime (set by server side).
    */
   created: string;

   /**
    * Object version.
    */
   gentime: number;

   /**
    * Chat type.
    */
   chatType: ChatType;

   /**
    * chat jid. Omitempty.
    */
   chat: JID;

   /**
    * external/internals links. Omitempty.
    */
   links: MessageLinks;

   /**
    * importance flag. Omitempty.
    */
   important: boolean;

   /**
    * datetime of message modification or deletion. Omitempty.
    */
   edited: string;

   /**
    * message was seen by anybody in chat. True or null. Omitempty.
    */
   received: boolean;

   /**
    * unused yet. Omitempty.
    */
   numReceived: number;

   /**
    * disable link previews. True or null. Omitempty.
    */
   nopreview: boolean;

   /**
    * has link previews. True or null. Omitempty.
    */
   hasPreviews: boolean;

   /**
    * previous message id in this chat. Uid or null. Omitempty.
    */
   prev: string;

   /**
    * this message is first in this chat. True or null. Omitempty.
    */
   isFirst: boolean;

   /**
    * this message is first in this chat. True or null. Omitempty.
    */
   isLast: boolean;

   /**
    * message reactions struct. Can be null. Omitempty.
    */
   reactions: MessageReaction[];

   /**
    * message that was replied to, if any. Omitempty.
    */
   replyTo: Message | null;

   /**
    * forwarded messages. Can be null. Also contains double of ReplyTo for backward compatibility. Omitempty.
    */
   linkedMessages: Message[];

   /**
    * has mention (@). True or null. Omitempty.
    */
   notice: boolean;

   /**
    * message has no pushes and did not affect any counters. Omitempty.
    */
   silently: boolean;

   /**
    * author can change this message until date. Can be null. Omitempty.
    */
   editableUntil: string;

   /**
    * index number of this message. Starts from 0. Null for deleted messages. Changes when any previous message wad deleted. Omitempty.
    */
   num: number | null;

   /**
    * debug information if any. Omitempty.
    */
   debug: string;

}

let NewMessage = function(e: any): Message { return {content: NewMessageContent(e["content"]), pushText: e["push_text"], from: e["from"], to: e["to"], messageId: e["message_id"], created: e["created"], gentime: e["gentime"], chatType: e["chat_type"], chat: e["chat"], links: e["links"], important: e["important"], edited: e["edited"], received: e["received"], numReceived: e["num_received"], nopreview: e["nopreview"], hasPreviews: e["has_previews"], prev: e["prev"], isFirst: e["is_first"], isLast: e["is_last"], reactions: e["reactions"].map(NewMessageReaction), replyTo: NewMessage(e["reply_to"]), linkedMessages: e["linked_messages"].map(NewMessage), notice: e["notice"], silently: e["silently"], editableUntil: e["editable_until"], num: e["num"], debug: e["_debug"]} }


/**
 * Website title and description.
 */
export interface MessageLinkPreview {
   /**
    * Website title or og:title content.
    */
   title: string;

   /**
    * Website description. Omitempty.
    */
   description: string;

}

let NewMessageLinkPreview = function(e: any): MessageLinkPreview { return {title: e["title"], description: e["description"]} }


/**
 * Checked message links. In short: "Click here: {link.Pattern}" => "Click here: <a href='{link.Url}'>{link.Text}</a>".
 */
export interface MessageLink {
   /**
    * Text fragment that should be replaced by link.
    */
   pattern: string;

   /**
    * Internal (tadateam://) or external link.
    */
   url: string;

   /**
    * Text replacement.
    */
   text: string;

   /**
    * Optional preview info, for websites. Omitempty.
    */
   preview: MessageLinkPreview | null;

   /**
    * Optional upload info. Omitempty.
    */
   uploads: Upload[];

   /**
    * Website previews disabled. Omitempty.
    */
   noPreview: boolean;

   /**
    * Optional youtube movie id. Omitempty.
    */
   youtubeId: string;

}

let NewMessageLink = function(e: any): MessageLink { return {pattern: e["pattern"], url: e["url"], text: e["text"], preview: NewMessageLinkPreview(e["preview"]), uploads: e["uploads"].map(NewUpload), noPreview: e["nopreview"], youtubeId: e["youtube_id"]} }


/**
 * Message emoji reaction.
 */
export interface MessageReaction {
   /**
    * Emoji.
    */
   name: string;

   /**
    * Number of reactions.
    */
   counter: number;

   /**
    * Details.
    */
   details: MessageReactionDetail[];

}

let NewMessageReaction = function(e: any): MessageReaction { return {name: e["name"], counter: e["counter"], details: e["details"].map(NewMessageReactionDetail)} }


/**
 * Message reaction detail.
 */
export interface MessageReactionDetail {
   /**
    * When reaction added, iso datetime.
    */
   created: string;

   /**
    * Reaction author.
    */
   sender: JID;

   /**
    * Reaction emoji.
    */
   name: string;

}

let NewMessageReactionDetail = function(e: any): MessageReactionDetail { return {created: e["created"], sender: e["sender"], name: e["name"]} }


/**
 * PDF preview of mediafile. Experimental.
 */
export interface PdfVersion {
   /**
    * Absolute url.
    */
   url: string;

   /**
    * First string of text content. Omitempty.
    */
   textPreview: string;

}

let NewPdfVersion = function(e: any): PdfVersion { return {url: e["url"], textPreview: e["text_preview"]} }

